package goat.projectLinearity.commands;

import goat.projectLinearity.ProjectLinearity;
import goat.projectLinearity.world.ConsegrityChunkGenerator;
import goat.projectLinearity.world.ChunkPreGenerator;
import org.bukkit.Bukkit;
import org.bukkit.World;
import org.bukkit.WorldCreator;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;
import org.bukkit.scheduler.BukkitRunnable;
import org.bukkit.GameRule;

import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;

public class RegenerateCommand implements CommandExecutor {
    public static final String WORLD_NAME = "Consegrity";
    private final ProjectLinearity plugin;

    private static final class PreGenState {
        Boolean oldMobSpawning;
        Integer oldRandomTickSpeed;
        Integer oldViewDistance;
        Integer oldSimulationDistance;
        Boolean oldAutoSave;
    }

    public RegenerateCommand(ProjectLinearity plugin) {
        this.plugin = plugin;
    }

    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (!(sender instanceof Player)) {
            sender.sendMessage("Only players can use this command.");
            return true;
        }
        Player player = (Player) sender;
        if (!player.hasPermission("consegrity.dev")) {
            player.sendMessage("You lack permission: consegrity.dev");
            return true;
        }

        player.sendMessage("Regenerating world '" + WORLD_NAME + "'...");

        // 1) Unload and delete existing world if present
        World existing = Bukkit.getWorld(WORLD_NAME);
        if (existing != null) {
            // Move any players out
            existing.getPlayers().forEach(p -> p.teleport(Bukkit.getWorlds().get(0).getSpawnLocation()));
            boolean ok = Bukkit.unloadWorld(existing, false);
            if (!ok) {
                player.sendMessage("Failed to unload existing world. Try again.");
                return true;
            }
            try {
                deleteWorldFolder(existing.getWorldFolder().toPath());
            } catch (IOException e) {
                player.sendMessage("Failed to delete world folder: " + e.getMessage());
                return true;
            }
        }

        // 2) Create fresh world using ConsegrityChunkGenerator
        WorldCreator wc = new WorldCreator(WORLD_NAME);
        wc.generateStructures(false);
        wc.generator(new ConsegrityChunkGenerator());
        World newWorld = Bukkit.createWorld(wc);
        if (newWorld == null) {
            player.sendMessage("World creation failed.");
            return true;
        }
        try { newWorld.setKeepSpawnInMemory(false); } catch (Throwable ignored) {}
// Set spawn and teleport; structures will populate as you explore
int sx = 0, sz = 0;
int sy = newWorld.getHighestBlockYAt(sx, sz) + 1;
newWorld.setSpawnLocation(sx, sy, sz);
player.teleport(newWorld.getSpawnLocation());
try { player.sendTitle("Central", "", 5, 40, 5); } catch (Throwable ignored) { player.sendMessage("Central"); }return true;
    }

    private void deleteWorldFolder(Path worldPath) throws IOException {
        if (worldPath == null) return;
        if (!Files.exists(worldPath)) return;
        Files.walkFileTree(worldPath, new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                Files.deleteIfExists(file);
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
                Files.deleteIfExists(dir);
                return FileVisitResult.CONTINUE;
            }
        });
    }

    private void applyPreGenSettings(World w, PreGenState s) {
        if (w == null) return;
        try { s.oldAutoSave = w.isAutoSave(); } catch (Throwable ignored) {}
        try { s.oldMobSpawning = w.getGameRuleValue(GameRule.DO_MOB_SPAWNING); } catch (Throwable ignored) {}
        try { s.oldRandomTickSpeed = w.getGameRuleValue(GameRule.RANDOM_TICK_SPEED); } catch (Throwable ignored) {}
        try { s.oldViewDistance = reflectGetInt(Bukkit.getServer(), "getViewDistance"); } catch (Throwable ignored) {}
        try { s.oldSimulationDistance = reflectGetInt(Bukkit.getServer(), "getSimulationDistance"); } catch (Throwable ignored) {}

        try { w.setAutoSave(false); } catch (Throwable ignored) {}
        try { w.setGameRule(GameRule.DO_MOB_SPAWNING, false); } catch (Throwable ignored) {}
        try { w.setGameRule(GameRule.RANDOM_TICK_SPEED, 0); } catch (Throwable ignored) {}
        try { if (s.oldViewDistance == null || s.oldViewDistance > 4) reflectSetInt(Bukkit.getServer(), "setViewDistance", 4); } catch (Throwable ignored) {}
        try { if (s.oldSimulationDistance == null || s.oldSimulationDistance > 4) reflectSetInt(Bukkit.getServer(), "setSimulationDistance", 4); } catch (Throwable ignored) {}
    }

    private void restorePreGenSettings(World w, PreGenState s) {
        if (w == null || s == null) return;
        try { if (s.oldMobSpawning != null) w.setGameRule(GameRule.DO_MOB_SPAWNING, s.oldMobSpawning); } catch (Throwable ignored) {}
        try { if (s.oldRandomTickSpeed != null) w.setGameRule(GameRule.RANDOM_TICK_SPEED, s.oldRandomTickSpeed); } catch (Throwable ignored) {}
        try { if (s.oldViewDistance != null) reflectSetInt(Bukkit.getServer(), "setViewDistance", s.oldViewDistance); } catch (Throwable ignored) {}
        try { if (s.oldSimulationDistance != null) reflectSetInt(Bukkit.getServer(), "setSimulationDistance", s.oldSimulationDistance); } catch (Throwable ignored) {}
        try { if (s.oldAutoSave != null) w.setAutoSave(s.oldAutoSave); } catch (Throwable ignored) {}
        try { w.save(); } catch (Throwable ignored) {}
    }

    private static Integer reflectGetInt(Object target, String method) {
        try {
            java.lang.reflect.Method m = target.getClass().getMethod(method);
            Object v = m.invoke(target);
            if (v instanceof Integer) return (Integer) v;
        } catch (Throwable ignored) {}
        return null;
    }

    private static void reflectSetInt(Object target, String method, int value) {
        try {
            java.lang.reflect.Method m = target.getClass().getMethod(method, int.class);
            m.invoke(target, value);
        } catch (Throwable ignored) {}
    }
}

